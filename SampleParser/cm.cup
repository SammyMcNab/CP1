
import absyn.*;

terminal BOOL, ELSE, IF, INT, RETURN, VOID, WHILE;
terminal TRUTH;              
terminal ID, NUM;

terminal PLUS, MINUS, MUL, DIV;
terminal LT, LE, GT, GE, EQ, NE;
terminal NOT, OR, AND;
terminal ASSIGN;
terminal SEMI, COMMA;
terminal LPAREN, RPAREN, LSBRACKET, RSBRACKET, LCURLY, RCURLY;

/* helper precedence symbol for dangling-else */
terminal IFX;

non terminal program;
non terminal declaration_list, declaration, var_declaration, type;
non terminal fun_declaration, fun_prototype, params, param_list, param;
non terminal compound_stmt, local_declarations, stmt_list, stmt;
non terminal expression_stmt, selection_stmt, iteration_stmt, return_stmt;
non terminal expression, var;
non terminal obool_expression, abool_expression, ubool_expression, simple_expression;
non terminal relop, additive_expression, addop, term, mulop;
non terminal signed_factor, factor, call, args, args_list;


/* ---- Precedence declarations (lowest to highest) ----
   This tells CUP how to resolve ambiguities:
   - ASSIGN is right-associative (a = b = c  means  a = (b = c))
   - OR is left-associative, lower than AND
   - Comparison operators are non-associative (a < b < c is invalid)
   - PLUS/MINUS are left-assoc, then MUL/DIV
   - NOT and unary minus are right-associative (highest among expressions)
   - IFX < ELSE resolves dangling else
*/


precedence right ASSIGN;
precedence left OR;
precedence left AND;
precedence nonassoc LT, LE, GT, GE, EQ, NE;
precedence left PLUS, MINUS;
precedence left MUL, DIV;
precedence right NOT;
precedence right IFX;
precedence right ELSE;

start with program;

/* ----------------------------Grammar Section-------------------- */
   

program
  ::= declaration_list:d
  {: RESULT = d; :}
  ;

declaration_list
  ::= declaration_list:d0 declaration:d1
  {: DecList node = d0;
    if (node == null) {
        RESULT = new DecList(d1, null);
    }
    else {
        while (node.tail != null) {
            node = node.tail;
        }
        node.tail = new DecList(d1, null);
        RESULT = d0;
    }
  :}

  |  declaration:d
  {: RESULT = new DecList(d, null); :}
  ;

declaration
  ::= var_declaration:v
  {: RESULT = v; :}
  |  fun_declaration:f
  {: RESULT = f; :}
  |  fun_prototype:fp
  {: RESULT = fp; :}
  ;

var_declaration
  ::= type:t ID:i SEMI
  {: RESULT = new GeneralDec(ileft, iright, t, i); :}
  |  type:t ID:i LSBRACKET NUM:n RSBRACKET SEMI
  {:  :}
  ;

type
  ::= BOOL
  |  INT
  |  VOID
  ;

fun_declaration
  ::= type ID LPAREN params RPAREN compound_stmt
  ;

fun_prototype
  ::= type ID LPAREN params RPAREN SEMI
  ;

params
  ::= param_list
  |  VOID
  ;

param_list
  ::= param_list COMMA param
  |  param
  ;

param
  ::= type ID
  |  type ID LSBRACKET RSBRACKET
  ;

compound_stmt
  ::= LCURLY local_declarations stmt_list RCURLY
  ;

local_declarations
  ::= local_declarations var_declaration
  |
  ;

stmt_list
  ::= stmt_list stmt
  |
  ;

stmt
  ::= expression_stmt
  |  compound_stmt
  |  selection_stmt
  |  iteration_stmt
  |  return_stmt
  ;

expression_stmt
  ::= expression SEMI
  |  SEMI
  ;

selection_stmt
  ::= IF LPAREN expression RPAREN stmt %prec IFX
  |  IF LPAREN expression RPAREN stmt ELSE stmt
  ;

iteration_stmt
  ::= WHILE LPAREN expression RPAREN stmt
  ;

return_stmt
  ::= RETURN expression SEMI
  |  RETURN SEMI
  ;

expression
  ::= var ASSIGN expression
  |  obool_expression
  ;

var
  ::= ID
  |  ID LSBRACKET expression RSBRACKET
  ;

obool_expression
  ::= obool_expression OR abool_expression
  |  abool_expression
  ;

abool_expression
  ::= abool_expression AND ubool_expression
  |  ubool_expression
  ;

ubool_expression
  ::= NOT ubool_expression
  |  simple_expression
  ;

simple_expression
  ::= additive_expression relop additive_expression
  |  additive_expression
  ;

relop
  ::= LE
  |  LT
  |  GT
  |  GE
  |  EQ
  |  NE
  ;

additive_expression
  ::= additive_expression addop term
  |  term
  ;

addop
  ::= PLUS
  |  MINUS
  ;

term
  ::= term mulop signed_factor
  |  signed_factor
  ;

mulop
  ::= MUL
  |  DIV
  ;

signed_factor
  ::= MINUS signed_factor
  |  factor
  ;

factor
  ::= LPAREN expression RPAREN
  |  var
  |  call
  |  NUM
  |  TRUTH
  ;



call
  ::= ID LPAREN args RPAREN
  ;

args
  ::= args_list
  |
  ;

args_list
  ::= args_list COMMA expression
  |  expression
  ;
