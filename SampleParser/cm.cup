
import absyn.*;

terminal BOOL, ELSE, IF, INT, RETURN, VOID, WHILE;
terminal boolean TRUTH;              
terminal String ID; 
terminal int NUM;

terminal PLUS, MINUS, MUL, DIV;
terminal LT, LE, GT, GE, EQ, NE;
terminal NOT, OR, AND;
terminal ASSIGN;
terminal SEMI, COMMA;
terminal LPAREN, RPAREN, LSBRACKET, RSBRACKET, LCURLY, RCURLY;
terminal ERROR;

/* helper precedence symbol for dangling-else */
terminal IFX;

non terminal DecList program, declaration_list;
non terminal Dec declaration, fun_declaration, fun_prototype;
non terminal GeneralDec var_declaration, param;
non terminal Type type;
non terminal VarDecList params, param_list, local_declarations;
non terminal Exp compound_stmt, stmt, expression_stmt, selection_stmt;
non terminal Exp iteration_stmt, return_stmt;
non terminal Exp expression, obool_expression, abool_expression, ubool_expression;
non terminal Exp simple_expression, additive_expression, term, signed_factor, factor;
non terminal Exp call;
non terminal VarExp var;
non terminal Integer relop, addop, mulop;
non terminal ExpList args, args_list, stmt_list;


/* ---- Precedence declarations (lowest to highest) ----
   This tells CUP how to resolve ambiguities:
   - ASSIGN is right-associative (a = b = c  means  a = (b = c))
   - OR is left-associative, lower than AND
   - Comparison operators are non-associative (a < b < c is invalid)
   - PLUS/MINUS are left-assoc, then MUL/DIV
   - NOT and unary minus are right-associative (highest among expressions)
   - IFX < ELSE resolves dangling else
*/


precedence right ASSIGN;
precedence left OR;
precedence left AND;
precedence nonassoc LT, LE, GT, GE, EQ, NE;
precedence left PLUS, MINUS;
precedence left MUL, DIV;
precedence right NOT;
precedence right IFX;
precedence right ELSE;


start with program;

/* ----------------------------Grammar Section-------------------- */
   

program
  ::= declaration_list:d
  {: RESULT = d; :}
  ;

declaration_list
  ::= declaration_list:d0 declaration:d1
  {: DecList node = d0;
    if (node == null) {
        RESULT = new DecList(d1, null);
    }
    else {
        while (node.tail != null) {
            node = node.tail;
        }
        node.tail = new DecList(d1, null);
        RESULT = d0;
    }
  :}

  |  declaration:d
  {: RESULT = new DecList(d, null); :}
  ;

declaration
  ::= var_declaration:v
  {: RESULT = v; :}
  |  fun_declaration:f
  {: RESULT = f; :}
  |  fun_prototype:fp
  {: RESULT = fp; :}
  ;

var_declaration
  ::= type:t ID:i SEMI
  {: RESULT = new GeneralDec(tleft, tright, t, i); :}
  |  type:t ID:i LSBRACKET NUM:n RSBRACKET SEMI
  {: RESULT = new ArrDec(tleft, tright, t, i, n); :}
  ;

type
  ::= BOOL:b
  {: RESULT = new Type(bleft, bright, "bool"); :}
  |  INT:i
  {: RESULT = new Type(ileft, iright, "int"); :}
  |  VOID:v
  {: RESULT = new Type(vleft, vright, "void"); :}
  ;

fun_declaration
  ::= type:t ID:i LPAREN params:p RPAREN compound_stmt:cs
  {: RESULT = new FunDec(tleft, tright, t, i, p, cs); :}
  ;

fun_prototype
  ::= type:t ID:i LPAREN params:p RPAREN SEMI
  {: RESULT = new FunPro(tleft, tright, t, i, p); :}
  ;

params
  ::= param_list:pl
  {: RESULT = pl; :}
  |  VOID:v
  {: RESULT = null; :}
  ;

param_list
  ::= param_list:pl COMMA param:p
  {: VarDecList node = pl;
     while (node.tail != null)
       node = node.tail;
     node.tail = new VarDecList(p, null);
     RESULT = pl;
  :}
  |  param:p
  {: RESULT = new VarDecList(p, null); :}
  ;

param
  ::= type:t ID:i
  {: RESULT = new GeneralDec(tleft, tright, t, i); :}
  |  type:t ID:i LSBRACKET RSBRACKET
  {: RESULT = new ArrDec(tleft, tright, t, i, 0); :}
  ;

compound_stmt
  ::= LCURLY:l local_declarations:ld stmt_list:sl RCURLY
  {: RESULT = new CompoundExp(lleft, lright, ld, sl); :}
  ;

local_declarations
  ::= local_declarations:ld var_declaration:vd
  {: VarDecList node = ld;
     if (node == null) {
       RESULT = new VarDecList(vd, null);
     } else {
       while (node.tail != null)
         node = node.tail;
       node.tail = new VarDecList(vd, null);
       RESULT = ld;
     }
  :}
  |
  {: RESULT = null; :}
  ;

stmt_list
  ::= stmt_list:sl stmt:s
  {: ExpList node = sl;
     if (node == null) {
       RESULT = new ExpList(s, null);
     } else {
       while (node.tail != null)
         node = node.tail;
       node.tail = new ExpList(s, null);
       RESULT = sl;
     }
  :}
  |
  {: RESULT = null; :}
  ;

stmt
  ::= expression_stmt:s
  {: RESULT = s; :}
  |  compound_stmt:s
  {: RESULT = s; :}
  |  selection_stmt:s
  {: RESULT = s; :}
  |  iteration_stmt:s
  {: RESULT = s; :}
  |  return_stmt:s
  {: RESULT = s; :}
  ;

expression_stmt
  ::= expression:e SEMI
  {: RESULT = e; :}
  |  SEMI:s
  {: RESULT = new NilExp(sleft, sright); :}
  ;

selection_stmt
  ::= IF:i LPAREN expression:e RPAREN stmt:s
  {: RESULT = new IfExp(ileft, iright, e, s, new NilExp(ileft, iright)); :}
  %prec IFX
  |  IF:i LPAREN expression:e RPAREN stmt:s1 ELSE stmt:s2
  {: RESULT = new IfExp(ileft, iright, e, s1, s2); :}
  ;

iteration_stmt
  ::= WHILE:w LPAREN expression:e RPAREN stmt:s
  {: RESULT = new WhileExp(wleft, wright, e, s); :}
  ;

return_stmt
  ::= RETURN:r expression:e SEMI
  {: RESULT = new ReturnExp(rleft, rright, e); :}
  |  RETURN:r SEMI
  {: RESULT = new ReturnExp(rleft, rright, new NilExp(rleft, rright)); :}
  ;

expression
  ::= var:v ASSIGN expression:e
  {: RESULT = new AssignExp(vleft, vright, v, e); :}
  |  obool_expression:o
  {: RESULT = o; :}
  ;

var
  ::= ID:i
  {: RESULT = new VarExp(ileft, iright, i); :}
  |  ID:i LSBRACKET expression:e RSBRACKET
  {: RESULT = new VarExp(ileft, iright, i, e); :}
  ;

obool_expression
  ::= obool_expression:o OR abool_expression:a
  {: RESULT = new OpExp(oleft, oright, o, OpExp.OR, a); :}
  |  abool_expression:a
  {: RESULT = a; :}
  ;

abool_expression
  ::= abool_expression:a AND ubool_expression:u
  {: RESULT = new OpExp(aleft, aright, a, OpExp.AND, u); :}
  |  ubool_expression:u
  {: RESULT = u; :}
  ;

ubool_expression
  ::= NOT:n ubool_expression:u
  {: RESULT = new OpExp(nleft, nright, null, OpExp.NOT, u); :}
  |  simple_expression:s
  {: RESULT = s; :}
  ;

simple_expression
  ::= additive_expression:a1 relop:r additive_expression:a2
  {: RESULT = new OpExp(a1left, a1right, a1, r, a2); :}
  |  additive_expression:a
  {: RESULT = a; :}
  ;

relop
  ::= LE:r
  {: RESULT = OpExp.LE; :}
  |  LT:r
  {: RESULT = OpExp.LT; :}
  |  GT:r
  {: RESULT = OpExp.GT; :}
  |  GE:r
  {: RESULT = OpExp.GE; :}
  |  EQ:r
  {: RESULT = OpExp.EQ; :}
  |  NE:r
  {: RESULT = OpExp.NE; :}
  ;

additive_expression
  ::= additive_expression:a addop:op term:t
  {: RESULT = new OpExp(aleft, aright, a, op, t); :}
  |  term:t
  {: RESULT = t; :}
  ;

addop
  ::= PLUS:op
  {: RESULT = OpExp.PLUS; :}
  |  MINUS:op
  {: RESULT = OpExp.MINUS; :}
  ;

term
  ::= term:t mulop:op signed_factor:f
  {: RESULT = new OpExp(tleft, tright, t, op, f); :}
  |  signed_factor:f
  {: RESULT = f; :}
  ;

mulop
  ::= MUL:op
  {: RESULT = OpExp.MUL; :}
  |  DIV:op
  {: RESULT = OpExp.DIV; :}
  ;

signed_factor
  ::= MINUS:m signed_factor:f
  {: RESULT = new OpExp(mleft, mright, null, OpExp.UMINUS, f); :}
  |  factor:f
  {: RESULT = f; :}
  ;

factor
  ::= LPAREN expression:e RPAREN
  {: RESULT = e; :}
  |  var:v
  {: RESULT = v; :}
  |  call:c
  {: RESULT = c; :}
  |  NUM:n
  {: RESULT = new IntExp(nleft, nright, String.valueOf(n)); :}
  |  TRUTH:t
  {: RESULT = new BoolExp(tleft, tright, t); :}
  ;

call
  ::= ID:i LPAREN args:a RPAREN
  {: RESULT = new CallExp(ileft, iright, i, a); :}
  ;

args
  ::= args_list:al
  {: RESULT = al; :}
  |
  {: RESULT = null; :}
  ;

args_list
  ::= args_list:al COMMA expression:e
  {: ExpList node = al;
     while (node.tail != null)
       node = node.tail;
     node.tail = new ExpList(e, null);
     RESULT = al;
  :}
  |  expression:e
  {: RESULT = new ExpList(e, null); :}
  ;
